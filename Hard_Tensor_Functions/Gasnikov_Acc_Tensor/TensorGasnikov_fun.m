%% Tensor Gasnikov's Method
% This code runs the third order tensor Gasnikov's method for the worst
% case function proposed by him

% Input parameters:
%  -- n:  Dimension of the problem
%  -- p:  Order of smoothness of the objective function (p=3 only)
%  -- k:  Parameter for Hard Tensor Functions
%  -- T:  Number of iterations
%  -- N:  Maximum number of iterations of the inner problem loop
% 
% Output:
%  -- x:   Optimization trajectory generated by the algoritm
%  -- tot_fun: Function values evaluated at the generated trajectories

function [y,tot_fun] = TensorGasnikov_fun(n,p,k,T,N)

U_k = zeros(k);
U_k(1:end-1,2:end) = -1*eye(k-1);
U_k = U_k +eye(k);

A_k = blkdiag(U_k,eye(n-k));

disp('Functions created')

%% Define Auxiliary variables and optimization parameters

L3 =6;      % Lispchitz Constants

tau = 1.1;
M = tau^2*L3;
gamma = tau*(tau+1)*L3/2;

f_opt = -k*p/(p+1);

C = p/2*sqrt((p+1)/(p-1)*(M^2 - L3^2));

options = optimset('Display','off','TolX',1e-12);

%% Initialization of the variables
A = 0;
tot_fun = zeros(1,T+1);

u = zeros(n,1);
y = zeros(n,T);

R_k = 5;

%% Compute initial condition for line search
disp('Start Iterations')

for i=1:T

    y_in = y(:,i);
    
    min_R = 1e-10;
    max_R = 10;

    [max_val,~,~,~] = compute_sol_gasnikov(max_R,A,y_in,p,u,n,tau,M,N,L3,gamma,options,A_k);
    [min_val,~,~,~] = compute_sol_gasnikov(min_R,A,y_in,p,u,n,tau,M,N,L3,gamma,options,A_k);
    
    condition =0;
    while condition == 0
    
        R_k = abs(max_R + min_R)/2;
        [val,y_out,Ap,a] = compute_sol_gasnikov(R_k,A,y_in,p,u,n,tau,M,N,L3,gamma,options,A_k);

        if (val <= min_val) && (val >= 1)
            min_val = val; 
            min_R = R_k;
        else
             max_val = val;
             max_R = R_k;
         end
%         if (val >= max_val) && (val <= 0.5)

%         end
        
        if (val>=0.5) && (val <=1)
            condition =1;
        end
        
    end
    y(:,i+1) = y_out;

    tot_fun(i+1) = bad_nesterov(y(:,i+1),A_k,p);

    u = u - a*grad_bad_nesterov(A_k,y(:,i+1),p);
    
    A = Ap;

%      semilogy(abs(tot_fun(1:i+1) - f_opt))
%     abs(abs(tot_fun(i+1) - f_opt));
    if abs(abs(tot_fun(i+1) - f_opt))<1e-16   % Early stopping condition
        break
    end
%     drawnow;
end
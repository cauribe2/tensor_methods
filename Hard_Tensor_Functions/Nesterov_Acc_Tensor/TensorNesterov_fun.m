%% Tensor Nesterov's Method
% This code runs the third order tensor Nesterov's method for the worst
% case function proposed by him

% Input parameters:
%  -- n:  Dimension of the problem
%  -- p:  Order of smoothness of the objective function (p=3 only)
%  -- k:  Parameter for Hard Tensor Functions
%  -- T:  Number of iterations
%  -- N:  Maximum number of iterations of the inner problem loop
% 
% Output:
%  -- x:   Optimization trajectory generated by the algoritm
%  -- tot_fun: Function values evaluated at the generated trajectories

function [x,tot_fun] = TensorNesterov_fun(n,p,k,T,N)


%% Definition of the function
U_k = zeros(k);
U_k(1:end-1,2:end) = -1*eye(k-1);
U_k = U_k +eye(k);
A_k = blkdiag(U_k,eye(n-k));

%% Define Auxiliary variables and optimization parameters

L3 =6;      % Lispchitz Constants

tau=1.1;    % Algorithm parameter, tau>1 is required
M = tau^2*L3;
gamma = tau*(tau+1)/2*L3;

f_opt = -k*p/(p+1);     % Optimal function value

C = p/2*sqrt((p+1)/(p-1)*(M^2 - L3^2));

options = optimset('Display','off','TolX',1e-12);

%% Initialization of the variables
x0 = zeros(n,1);
x(:,1) = TensorNesterovInner(x0,n,tau,M,L3,gamma,options,N,A_k,p);

nu = zeros(n,1);
sk = zeros(n,1);

tot_fun = zeros(1,T+1);
tot_fun = bad_nesterov(x(:,1),A_k,p);

for i=1:T
    
    A = (((p-1)*(M^2-L3^2))/(4*(p+1)*M^2))^(p/2)*(i/(p+1))^(p+1);
    Ap = (((p-1)*(M^2-L3^2))/(4*(p+1)*M^2))^(p/2)*((i+1)/(p+1))^(p+1);
    a = Ap-A;
    
    y = A/Ap*x(:,i) + a/Ap*nu;    
    
    xt = TensorNesterovInner(y,n,tau,M,L3,gamma,options,N,A_k,p);

    x(:,i+1) = xt + y;

    tot_fun(i+1) = bad_nesterov(x(:,i+1),A_k,p);

    sk = sk + a*grad_bad_nesterov(A_k,x(:,i+1),p);
 
    nu = - (factorial(p)/(C*norm(sk,2)^(p-1)))^(1/p)*sk;

%      semilogy(abs(tot_fun(1:i+1) - f_opt))
%     drawnow;
end


